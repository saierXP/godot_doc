# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, Juan Linietsky, Ariel Manzur and the Godot community (CC-BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-28 20:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/classes/class_webrtcmultiplayer.rst:10
msgid "WebRTCMultiplayer"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:12
msgid "**Inherits:** :ref:`NetworkedMultiplayerPeer<class_NetworkedMultiplayerPeer>` **<** :ref:`PacketPeer<class_PacketPeer>` **<** :ref:`Reference<class_Reference>` **<** :ref:`Object<class_Object>`"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:14
msgid "A simple interface to create a peer-to-peer mesh network composed of :ref:`WebRTCPeerConnection<class_WebRTCPeerConnection>` that is compatible with the :ref:`MultiplayerAPI<class_MultiplayerAPI>`."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:17
msgid "Description"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:19
msgid "This class constructs a full mesh of :ref:`WebRTCPeerConnection<class_WebRTCPeerConnection>` (one connection for each peer) that can be used as a :ref:`MultiplayerAPI.network_peer<class_MultiplayerAPI_property_network_peer>`."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:21
msgid "You can add each :ref:`WebRTCPeerConnection<class_WebRTCPeerConnection>` via :ref:`add_peer<class_WebRTCMultiplayer_method_add_peer>` or remove them via :ref:`remove_peer<class_WebRTCMultiplayer_method_remove_peer>`. Peers must be added in :ref:`WebRTCPeerConnection.STATE_NEW<class_WebRTCPeerConnection_constant_STATE_NEW>` state to allow it to create the appropriate channels. This class will not create offers nor set descriptions, it will only poll them, and notify connections and disconnections."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:23
msgid ":ref:`NetworkedMultiplayerPeer.connection_succeeded<class_NetworkedMultiplayerPeer_signal_connection_succeeded>` and :ref:`NetworkedMultiplayerPeer.server_disconnected<class_NetworkedMultiplayerPeer_signal_server_disconnected>` will not be emitted unless ``server_compatibility`` is ``true`` in :ref:`initialize<class_WebRTCMultiplayer_method_initialize>`. Beside that data transfer works like in a :ref:`NetworkedMultiplayerPeer<class_NetworkedMultiplayerPeer>`."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:26
msgid "Properties"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:29
#: ../../docs/classes/class_webrtcmultiplayer.rst:46
msgid ":ref:`bool<class_bool>`"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:29
msgid "refuse_new_connections"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:29
msgid "``false`` *(parent override)*"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:31
msgid ":ref:`TransferMode<enum_NetworkedMultiplayerPeer_TransferMode>`"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:31
msgid "transfer_mode"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:31
msgid "``2`` *(parent override)*"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:35
msgid "Methods"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:38
#: ../../docs/classes/class_webrtcmultiplayer.rst:48
msgid ":ref:`Error<enum_@GlobalScope_Error>`"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:38
msgid ":ref:`add_peer<class_WebRTCMultiplayer_method_add_peer>` **(** :ref:`WebRTCPeerConnection<class_WebRTCPeerConnection>` peer, :ref:`int<class_int>` peer_id, :ref:`int<class_int>` unreliable_lifetime=1 **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:40
#: ../../docs/classes/class_webrtcmultiplayer.rst:50
msgid "void"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:40
msgid ":ref:`close<class_WebRTCMultiplayer_method_close>` **(** **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:42
#: ../../docs/classes/class_webrtcmultiplayer.rst:44
msgid ":ref:`Dictionary<class_Dictionary>`"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:42
msgid ":ref:`get_peer<class_WebRTCMultiplayer_method_get_peer>` **(** :ref:`int<class_int>` peer_id **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:44
msgid ":ref:`get_peers<class_WebRTCMultiplayer_method_get_peers>` **(** **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:46
msgid ":ref:`has_peer<class_WebRTCMultiplayer_method_has_peer>` **(** :ref:`int<class_int>` peer_id **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:48
msgid ":ref:`initialize<class_WebRTCMultiplayer_method_initialize>` **(** :ref:`int<class_int>` peer_id, :ref:`bool<class_bool>` server_compatibility=false **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:50
msgid ":ref:`remove_peer<class_WebRTCMultiplayer_method_remove_peer>` **(** :ref:`int<class_int>` peer_id **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:54
msgid "Method Descriptions"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:58
msgid ":ref:`Error<enum_@GlobalScope_Error>` **add_peer** **(** :ref:`WebRTCPeerConnection<class_WebRTCPeerConnection>` peer, :ref:`int<class_int>` peer_id, :ref:`int<class_int>` unreliable_lifetime=1 **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:60
msgid "Add a new peer to the mesh with the given ``peer_id``. The :ref:`WebRTCPeerConnection<class_WebRTCPeerConnection>` must be in state :ref:`WebRTCPeerConnection.STATE_NEW<class_WebRTCPeerConnection_constant_STATE_NEW>`."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:62
msgid "Three channels will be created for reliable, unreliable, and ordered transport. The value of ``unreliable_lifetime`` will be passed to the ``maxPacketLifetime`` option when creating unreliable and ordered channels (see :ref:`WebRTCPeerConnection.create_data_channel<class_WebRTCPeerConnection_method_create_data_channel>`)."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:68
msgid "void **close** **(** **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:70
msgid "Close all the add peer connections and channels, freeing all resources."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:76
msgid ":ref:`Dictionary<class_Dictionary>` **get_peer** **(** :ref:`int<class_int>` peer_id **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:78
msgid "Return a dictionary representation of the peer with given ``peer_id`` with three keys. ``connection`` containing the :ref:`WebRTCPeerConnection<class_WebRTCPeerConnection>` to this peer, ``channels`` an array of three :ref:`WebRTCDataChannel<class_WebRTCDataChannel>`, and ``connected`` a boolean representing if the peer connection is currently connected (all three channels are open)."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:84
msgid ":ref:`Dictionary<class_Dictionary>` **get_peers** **(** **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:86
msgid "Returns a dictionary which keys are the peer ids and values the peer representation as in :ref:`get_peer<class_WebRTCMultiplayer_method_get_peer>`."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:92
msgid ":ref:`bool<class_bool>` **has_peer** **(** :ref:`int<class_int>` peer_id **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:94
msgid "Returns ``true`` if the given ``peer_id`` is in the peers map (it might not be connected though)."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:100
msgid ":ref:`Error<enum_@GlobalScope_Error>` **initialize** **(** :ref:`int<class_int>` peer_id, :ref:`bool<class_bool>` server_compatibility=false **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:102
msgid "Initialize the multiplayer peer with the given ``peer_id`` (must be between 1 and 2147483647)."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:104
msgid "If ``server_compatibilty`` is ``false`` (default), the multiplayer peer will be immediately in state :ref:`NetworkedMultiplayerPeer.CONNECTION_CONNECTED<class_NetworkedMultiplayerPeer_constant_CONNECTION_CONNECTED>` and :ref:`NetworkedMultiplayerPeer.connection_succeeded<class_NetworkedMultiplayerPeer_signal_connection_succeeded>` will not be emitted."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:106
msgid "If ``server_compatibilty`` is ``true`` the peer will suppress all :ref:`NetworkedMultiplayerPeer.peer_connected<class_NetworkedMultiplayerPeer_signal_peer_connected>` signals until a peer with id :ref:`NetworkedMultiplayerPeer.TARGET_PEER_SERVER<class_NetworkedMultiplayerPeer_constant_TARGET_PEER_SERVER>` connects and then emit :ref:`NetworkedMultiplayerPeer.connection_succeeded<class_NetworkedMultiplayerPeer_signal_connection_succeeded>`. After that the signal :ref:`NetworkedMultiplayerPeer.peer_connected<class_NetworkedMultiplayerPeer_signal_peer_connected>` will be emitted for every already connected peer, and any new peer that might connect. If the server peer disconnects after that, signal :ref:`NetworkedMultiplayerPeer.server_disconnected<class_NetworkedMultiplayerPeer_signal_server_disconnected>` will be emitted and state will become :ref:`NetworkedMultiplayerPeer.CONNECTION_CONNECTED<class_NetworkedMultiplayerPeer_constant_CONNECTION_CONNECTED>`."
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:112
msgid "void **remove_peer** **(** :ref:`int<class_int>` peer_id **)**"
msgstr ""

#: ../../docs/classes/class_webrtcmultiplayer.rst:114
msgid "Remove the peer with given ``peer_id`` from the mesh. If the peer was connected, and :ref:`NetworkedMultiplayerPeer.peer_connected<class_NetworkedMultiplayerPeer_signal_peer_connected>` was emitted for it, then :ref:`NetworkedMultiplayerPeer.peer_disconnected<class_NetworkedMultiplayerPeer_signal_peer_disconnected>` will be emitted."
msgstr ""
